<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <title>"Wer wird Millionär?" LLM Benchmark</title>
    <link rel="stylesheet" href="leaderboard/grid.css">
    <link rel="stylesheet" href="leaderboard/styles.css">
    <style>
        @media (max-width: 640px) {            
            cell {
                grid-column: span 8 !important;
            }
            
            .model-name {
                min-width: 0 !important;
            }
            
            .model-name-cell-spacing {
                width: 8px !important;
            }
        }
    </style>
</head>
<body>

    <cell span=2>
        <h1>Wer wird Millionär?<br>LLM Benchmark</h1>
    </cell>

    <cell span=6>
        <p>A benchmark using questions from the German version of "Who Wants to Be a Millionaire?". It consists of 45 games, each with 15 questions of increasing difficulty. All tested models played through the 45 games at least once. Each game is ended with the first incorrect answer, and the winnings at that point are recorded. No jokers were used.</p>
        <p>The initial questions often involve wordplay and idioms, requiring a deep understanding of the German language. These proved most challenging for LLMs, though they are easily solvable by the average German.</p>
    </cell>

    <cell span=2>
        <h2>Performance<br><a href="#" id="local-link" class="selected">Local</a> / <a href="#" id="cloud-link" class="unselected">Cloud</a></h2>
        <div class="color-legend" id="local-legend">
            <div class="legend-item">
                <div class="color-marker"></div>
                <span>Reasoning</span>
            </div>
            <div class="legend-item">
                <div class="color-marker non-thinking"></div>
                <span>Non-Reasoning</span>
            </div>
        </div>
        <div class="color-legend" id="cloud-legend" style="display: none;">
            <div class="legend-item">
                <div class="color-marker open-source"></div>
                <span>Open Weight</span>
            </div>
            <div class="legend-item">
                <div class="color-marker closed-source"></div>
                <span>Closed Weight</span>
            </div>
        </div>
    </cell>

    <cell span=6>
        <table class="performance-table" style="width: 100%; table-layout: fixed;">
            <tbody id="leaderboard-tbody">
            </tbody>
        </table><br>
        <p>A model's Performance Score is calculated from the average winnings of a test run, after discarding the top 5 and bottom 5 outlier rounds. The final score shown is the median (middle value) of all test runs for that model. For models tested multiple times, the range between their best and worst scores is also shown to indicate performance consistency.</p>
        <p>My selection of LLMs is limited as I ran them on my Framework Laptop 13 (AMD Ryzen 5 7640U with 32 GB of RAM), which necessitated the use of smaller models. All models were Q4_K_M quantized and, if available, recommended settings were used.</p><p>The entire project, including detailed results for each model and the questionnaire, is open source and available on <a href="https://github.com/ikiruneo/millionaire-bench">GitHub</a>.</p>
    </cell>
    
    <script>
        // Current leaderboard type
        let currentLeaderboard = 'local'; // Default to local
        
        // Load color mapping from JSON file
        async function loadColorMapping() {
            try {
                const response = await fetch('leaderboard/color_mapping.json');
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return await response.json();
            } catch (error) {
                console.error('Error loading color mapping:', error);
                // Return a default mapping if loading fails
                return {
                    "local_instruct": [],
                    "closed_source": [],
                    "local_thinking": [],
                    "open_source": []
                };
            }
        }
        
        // Load leaderboard data from JSON file
        async function loadLeaderboardData() {
            try {
                let fileName;
                if (currentLeaderboard === 'local') {
                    fileName = 'leaderboard/leaderboard_local.json';
                } else if (currentLeaderboard === 'cloud') {
                    fileName = 'leaderboard/leaderboard_cloud.json';
                } else {
                    fileName = 'leaderboard/leaderboard_data.json'; // fallback to combined
                }
                
                // Try to load the JSON file using fetch from the same directory
                const response = await fetch(fileName);
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return await response.json();
            } catch (error) {
                console.error('Error loading leaderboard data:', error);
                return [];
            }
        }
        
        // Function to populate the leaderboard
        async function populateLeaderboard() {
            // Load both leaderboard data and color mapping
            const [dataObject, colorMapping] = await Promise.all([
                loadLeaderboardData(),
                loadColorMapping()
            ]);
            
            if (!dataObject || !dataObject.models || dataObject.models.length === 0) {
                console.error('No leaderboard data found');
                document.getElementById('leaderboard-tbody').innerHTML = '<tr><td colspan="2">No data available. Please run the generate_leaderboard.py script in the leaderboard folder to create leaderboard_local.json and leaderboard_cloud.json</td></tr>';
                return;
            }
            const leaderboardData = dataObject.models;
            const tbody = document.getElementById('leaderboard-tbody');
            tbody.innerHTML = ''; // Clear existing content
            
            // Fixed logarithmic scale where 1,000,000€ = 100%
            const maxValue = 1000000; // 1,000,000€ is the fixed maximum
            const a = 50.00500050005; // Constant for logarithmic scale
            const logMaxValue = Math.log(maxValue + a) - Math.log(a); // Max value for scaling
            
            // Function to get color class based on color mapping
            function getColorClass(modelName, colorMapping) {
                const lowerModelName = modelName.toLowerCase();
                
                // Map category names to hex colors
                const categoryToColor = {
                    "local_instruct": "#CC5E21",
                    "local_thinking": "#0294C9", 
                    "closed_source": "#7648C9",
                    "open_source": "#1FA88C"
                };
                
                // Check each category for exact matches first
                for (const [category, modelList] of Object.entries(colorMapping)) {
                    if (Array.isArray(modelList)) {
                        for (const model of modelList) {
                            if (lowerModelName === model.toLowerCase()) {
                                // If the model is in this category, return the color class for that category
                                const hexColor = categoryToColor[category];
                                if (hexColor) {
                                    return `color-${hexColor.replace('#', '')}`;
                                }
                                break;
                            }
                        }
                    }
                }
                
                // If no exact match found, try partial matches as fallback
                for (const [category, modelList] of Object.entries(colorMapping)) {
                    if (Array.isArray(modelList)) {
                        for (const model of modelList) {
                            if (lowerModelName.includes(model.toLowerCase())) {
                                // If the model contains this category's model name, return the color class for that category
                                const hexColor = categoryToColor[category];
                                if (hexColor) {
                                    return `color-${hexColor.replace('#', '')}`;
                                }
                                break;
                            }
                        }
                    }
                }
                
                // Default fallback color
                return 'default-color';
            }
            
            leaderboardData.forEach(item => {
                const row = document.createElement('tr');
                
                // Calculate bar width using the fixed logarithmic scale
                // Using the log_percentage from the Python script (pre-calculated)
                const barWidth = item.log_percentage;
                
                // Determine bar color based on model name using color mapping
                const barColorClass = getColorClass(item.model_name, colorMapping);
                
                // Create a custom function to format numbers with non-breaking spaces
                function formatNumberWithNbsp(num) {
                    return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, '\u00A0'); // \u00A0 is non-breaking space
                }
                
                // Create a simple score display
                const formattedScore = formatNumberWithNbsp(item.median_value);
                
                // Check if we have deviation data (models with multiple results)
                if (item.low_deviation_euros !== null && item.high_deviation_euros !== null) {
                    // Calculate the positions of error bars based on the bar value +/- euro deviations
                    const barValue = item.median_value;
                    const lowValue = Math.max(0, barValue - item.low_deviation_euros);
                    const highValue = Math.min(maxValue, barValue + item.high_deviation_euros); // Cap at fixed max for display
                    const uncappedHighValue = barValue + item.high_deviation_euros; // Actual uncapped value for tooltip
                    const isHighValueCapped = (barValue + item.high_deviation_euros) > maxValue; // Check if high value was capped
                    
                    // Calculate average of absolute deviations to represent overall uncertainty
                    // Using the example: average = (low_deviation_euros + high_deviation_euros) / 2
                    // This represents the average magnitude of variation regardless of direction
                    const averageDeviation = (item.low_deviation_euros + item.high_deviation_euros) / 2;
                    const formattedNetDeviation = formatNumberWithNbsp(Math.round(averageDeviation));
                    
                    // Calculate positions using the fixed logarithmic scale
                    const logBarValue = (Math.log(barValue + a) - Math.log(a)) / logMaxValue * 100;
                    const logLowValue = (Math.log(lowValue + a) - Math.log(a)) / logMaxValue * 100;
                    const logHighValue = (Math.log(highValue + a) - Math.log(a)) / logMaxValue * 100;
                    
                    const lowBarPos = logLowValue;
                    const barPos = logBarValue;
                    const highBarPos = Math.min(100, logHighValue); // Cap at 100%
                    
                    // Calculate error bar width and position
                    const errorBarWidth = Math.max(1, highBarPos - lowBarPos);
                    const errorBarLeft = Math.max(0, lowBarPos);
                    
                    // Format the detailed deviation for the tooltip (no separators in tooltip) - use actual uncapped values
                    const detailedDeviation = `Score: ${item.median_value}€\nRange: ${Math.max(0, item.median_value - item.low_deviation_euros)}€ to ${uncappedHighValue}€`;
                    
                    row.innerHTML = `
                        <td style="padding: 0;">
                            <div style="display: flex; align-items: center;">
                                <div class="rank" style="width: 40px; height: 40px; padding: 0; flex-shrink: 0;">${item.rank}</div>
                                <div class="model-name-cell-spacing" style="width: 12px; flex-shrink: 0;"></div> <!-- Fixed 12px spacing -->
                                <div class="model-name" style="min-width: 200px; flex: 1;">
                                    <div style="display: flex; flex-direction: column; height: 40px; justify-content: flex-start; align-items: stretch; position: relative; top: -2px;">
                                        <div style="display: flex; justify-content: space-between; align-items: center; gap: 8px; margin-top: 1px; position: relative; top: -4px;">
                                            <div style="display: flex; align-items: center; gap: 8px; flex: 1; min-width: 0;">
                                                <span class="model-name-text" style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex: 1; min-width: 0; font-size: 0.875rem;" title="${item.model_name}">${item.model_name}</span>
                                            </div>
                                            <div style="display: flex; align-items: center; gap: 8px; white-space: nowrap; flex-shrink: 0;">
                                                <div class="score-main" style="font-size: 0.875rem; font-weight: 400; min-width: 60px; text-align: right;" title="${detailedDeviation}">${formattedScore}€</div>
                                                <div class="score-percentage" style="font-size: 0.875rem; color: #666; min-width: 40px; text-align: right;">${item.log_percentage.toFixed(1)}%</div>
                                            </div>
                                        </div>
                                        <div class="score-cell" style="margin-top: 1px; flex: 1; display: flex; align-items: flex-end;">
                                            <div class="score-bar-container tooltip-trigger" style="width: 100%; height: 14px; position: relative;">
                                                <div class="score-bar ${barColorClass}" style="width: ${barWidth}%; height: 100%;"></div>
                                                <!-- Error bar showing range of deviation -->
                                                <div class="error-margin ${isHighValueCapped ? 'error-margin-capped' : ''}" style="left: ${errorBarLeft}%; width: ${errorBarWidth}%;"></div>
                                                <div class="tooltip hidden">${detailedDeviation}</div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </td>
                    `;                } else {
                    // For models with only 1 result, show just the bar without error bars
                    const detailedDeviation = "";
                    row.innerHTML = `
                        <td style="padding: 0;">
                            <div style="display: flex; align-items: center;">
                                <div class="rank" style="width: 40px; height: 40px; padding: 0; flex-shrink: 0;">${item.rank}</div>
                                <div class="model-name-cell-spacing" style="width: 12px; flex-shrink: 0;"></div> <!-- Fixed 12px spacing -->
                                <div class="model-name" style="min-width: 200px; flex: 1;">
                                    <div style="display: flex; flex-direction: column; height: 40px; justify-content: flex-start; align-items: stretch; position: relative; top: -2px;">
                                        <div style="display: flex; justify-content: space-between; align-items: center; gap: 8px; margin-top: 1px; position: relative; top: -4px;">
                                            <div style="display: flex; align-items: center; gap: 8px; flex: 1; min-width: 0;">
                                                <span class="model-name-text" style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex: 1; min-width: 0; font-size: 0.875rem;" title="${item.model_name}">${item.model_name}</span>
                                            </div>
                                            <div style="display: flex; align-items: center; gap: 8px; white-space: nowrap; flex-shrink: 0;">
                                                <div class="score-main" style="font-size: 0.875rem; font-weight: 400; min-width: 60px; text-align: right;" title="${detailedDeviation}">${formattedScore}€</div>
                                                <div class="score-percentage" style="font-size: 0.875rem; color: #666; min-width: 40px; text-align: right;">${item.log_percentage.toFixed(1)}%</div>
                                            </div>
                                        </div>
                                        <div class="score-cell" style="margin-top: 1px; flex: 1; display: flex; align-items: flex-end;">
                                            <div class="score-bar-container tooltip-trigger" style="width: 100%; height: 14px; position: relative;">
                                                <div class="score-bar ${barColorClass}" style="width: ${barWidth}%; height: 100%;"></div>
                                                <div class="tooltip hidden"></div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </td>
                    `;
                }
                
                tbody.appendChild(row);
            });
        }

        // Function to switch between local and cloud leaderboards
        function switchLeaderboard(type) {
            currentLeaderboard = type;
            
            // Update the selected/unselected links
            const localLink = document.getElementById('local-link');
            const cloudLink = document.getElementById('cloud-link');
            
            if (type === 'local') {
                if (localLink) {
                    localLink.className = 'selected';
                }
                if (cloudLink) {
                    cloudLink.className = 'unselected';
                }
            } else if (type === 'cloud') {
                if (localLink) {
                    localLink.className = 'unselected';
                }
                if (cloudLink) {
                    cloudLink.className = 'selected';
                }
            }
            
            // Show the appropriate legend based on the leaderboard type
            const localLegend = document.getElementById('local-legend');
            const cloudLegend = document.getElementById('cloud-legend');
            
            if (type === 'local') {
                if (localLegend) {
                    localLegend.style.display = 'flex';
                }
                if (cloudLegend) {
                    cloudLegend.style.display = 'none';
                }
            } else if (type === 'cloud') {
                if (localLegend) {
                    localLegend.style.display = 'none';
                }
                if (cloudLegend) {
                    cloudLegend.style.display = 'flex';
                }
            }
            
            // Reload the leaderboard with the new data
            populateLeaderboard();
        }
        
        // Run when the page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Show the default legend (local) on initial load
            const localLegend = document.getElementById('local-legend');
            const cloudLegend = document.getElementById('cloud-legend');
            if (localLegend) {
                localLegend.style.display = 'flex';
            }
            if (cloudLegend) {
                cloudLegend.style.display = 'none';
            }
            
            populateLeaderboard();
            
            // Add event listeners to the links
            const localLink = document.getElementById('local-link');
            const cloudLink = document.getElementById('cloud-link');
            
            if (localLink) {
                localLink.addEventListener('click', function(e) {
                    e.preventDefault();
                    switchLeaderboard('local');
                });
            }
            
            if (cloudLink) {
                cloudLink.addEventListener('click', function(e) {
                    e.preventDefault();
                    switchLeaderboard('cloud');
                });
            }
        });
        
        // Handle tooltip display
        document.addEventListener('mouseover', function(e) {
            const tooltipTrigger = e.target.closest('.tooltip-trigger');
            if (tooltipTrigger) {
                const tooltip = tooltipTrigger.querySelector('.tooltip');
                if (tooltip && tooltip.textContent.trim() !== '') {
                    tooltip.classList.remove('hidden');
                    tooltip.classList.add('visible');
                }
            }
        });
        
        document.addEventListener('mouseout', function(e) {
            const tooltipTrigger = e.target.closest('.tooltip-trigger');
            if (tooltipTrigger) {
                const tooltip = tooltipTrigger.querySelector('.tooltip');
                if (tooltip) {
                    tooltip.classList.remove('visible');
                    tooltip.classList.add('hidden');
                }
            }
        });
    </script>
</body>
</html>
